- Implementing access cotnrols means building a system that can help make a decision as to which users can perform which actions on a given asset
- There are many different approaches to defiing and represnting access control policies
- The two that you will study in this module are:
    - Access control matrices
    - Role based access control
- **20.8.1 Access control matrices**
    - In access control matrices (ACMs), access control policies are set out as action entries in a matrix
    - Typically, users are listed as rows and assets as columns, with the permissions in the matrix cell at their intersection
    - Assets could refer to anything from files to databases or even to a single record, with the granularity of the asset determined by context
    - Once defined, an access control matrix provides a simple lookup table
    - Although easy to read, ACMs are an inefficient an limited method of defining and maintaining an access control policy when there is a large number of users and/or assets to consider: a large oganization with tens of thousands of employees and similar numbers of assets will need to define and maintain a matrix with millions of cells
    - Rather, ACMs are more normally used as a way of visualizing access control that has been implemented in a different way, such as using roles
- **20.8.2 Role based access control**
    - When an organization has large numbers of users and assets, one of the means by which access control can be made manageable to the whole organization is through the use of roles in role based access control, or RBAC
    - Like ACMs, RBAC works with permissions: sets of actions that are allowed on an asset
    - Unlike ACMs, however, RBAC groups collections of permission into roles to structure the permit or deny decision
    - A user is assigned one or more roles and is granted only those permission on asset that those roles permit
    - There are three assumptions that affect how efficiently RBAC will work within an organization:
        - Users and permission can change often, while roles seldom change
        - There are many fewer roles than users
        - Each user can have more than one role
    - The three assumption are true of most organizations and RBAC makes access control easier ot manage: if someone changes their job within an organisation - they are promoted for instance - the only change needed to the access control policy is to remove them from the roles associated with their old job and to assign them to the roles associated with their new job
    - Compare this with an equivalent ACM in which each entry in the row assoicated with that user would have to be changed
    - Roles give other benefits too: users can easly change roles in sequence (as when they change projects and need access to different assts) or take two or more roles simultaneously (as when they are both a database user and a database manager) so that roles can be combined through inheritance
    - The rest of this week's study describes the various components of RBAC and how they combine to create an RBAC policy
- **20.8.3 Defining roles**
    - Roles are collecitons of permission that are the actions allowed on an object
    - Given that we have chosen the basic actions on objects to be Create, Read, Update, and Destroy, then for any object, these become the basic roles
    - Higher-level roles are built on top of these Level 0 roles through inheritance
    - A level 1 role will accumulate the permissions from every Level 0 role it inherits from
    - More generally, a level n role will accumulate the permissions from every role it inherits from: a role at level n can inherit from any lower level
    - The ways in which roles are defined differ
    - With the approach to RBAC chosen for this modules, we have taken an object focused approach: roles are defined from the possible actions on objects
    - Another approach is to identify employees' needs for access and to base the role definitions on these needs
- **20.8.4 Building an RBAC**
    - To build an RBAC we must decide which subjects, objects, and roles there are - or more simply, which users need to access which information assets and in whcih ways
    - Given the objects, the level 0 roles are defined as above; higher-level roles are then defined by inheritance. Then we can assign users to roles
    - As with ACMs, we will use simple tables to present an RBAC policy
    - Given this, there will be one table to define the role hierarchy, and one that assigns users to those roles
    - In the simples RBACs there are no roles other than the level 0 roles, which are already defined, and so a single User/Role table is sufficient
    - A simple User/Role table
        - Users in the first column are associated with all the roles they hold in the second
        - In this table we can see that user 1 has a single level 0 role: they can create-Asset1
        - User2 and User3 have more complex roles, that for User2 being restricted to a single asset - Asset2 - but user 3 and user 4 having access to both asset1 and asset2
        - Each row of this table is called a User assignment, or UA
        - ![fdsajfakjhf.JPG](../../../_resources/fdsajfakjhf.JPG)
- **20.8.5 More complex roles**
    - Whereas level 0 roles have predetermined names, higher level roles can have more informative names
    - Consider a situation involving two roles: an asset user that can read an asset, and an sset manager that can read and create an asset
        - An asset manager is sometimes an asset user and, although it would be possible to define their roles in terms of level 0 roles, we can highlight this relationship through the role assignments, with the asset manager inheriting their asset user role
        - ![fasdfjasf.JPG](../../../_resources/fasdfjasf.JPG)
        - Here, the asset manager role inherits from the asset-user role and so inherits that roles permission to read and update
        - We can use this hierarchy to encode the repeated roles in table 20.4
        - ![fadfafafdafda.JPG](../../../_resources/fadfafafdafda.JPG)
        - Role hierarchies make access control easier to maintain than access control matrices: a change in a role automatically means that all users with that role will experience those hcanges. Care is needed, however, as the next activity shows
- **20.8.6 A larger example**
    - Le Dolce Colline has four employees, Pat, Robin, Val, and Drew
    - They have three databases holding CustomerOrders, the StockHeld and StockOrders
    - They want to be able to carry out a number of sensitive tasks
        - Record and edit customer orders in the customerOrders database
        - to check in new stock in the StockHeld database
        - to read the StockHeld database and, when necessary, to place orders to replenish stock and record items in the StockOrders database
        - to record picked stock to be shipped for an order in the StockHeld database
    - Pat records customer orders, Robin checks in new stock, Val places orders to replenish stock and Drew records shipped orders
    - Le Dolce Colline wants to design an RBAC system for its databases
    - We first list the Level 0 roles in table 20.8
    - ![daffasfsdadf.JPG](../../../_resources/daffasfsdadf.JPG)
    - Then we define the Level 1 roles in table 20.9
    - ![dafafdaf.JPG](../../../_resources/dafafdaf.JPG)
    - Finally we define the user assignments in table 20.10
    - ![dfasfdafaf.JPG](../../../_resources/dfasfdafaf.JPG)